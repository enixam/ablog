---
title: 'Useful Shiny Patterns '
author: Qiushi Yan
date: '2021-11-09'
slug: []
categories: []
tags: []
subtitle: ''
summary: 'tricks and patterns when building shiny apps'
authors: []
lastmod: '2021-11-09T22:24:23-06:00'
draft: yes
link-citations: yes
image:
  caption: ''
  focal_point: ''
  preview_only: no
---

## Dynamic Updating 


You can resolve this problem by “freezing” the input with `freezeReactiveValue()`. This ensures that any reactives or outputs that use the input won’t be updated until the next full round of invalidation.

```r
server <- function(input, output, session) {
  dataset <- reactive(get(input$dataset, "package:datasets"))
  
  observeEvent(input$dataset, {
    freezeReactiveValue(input, "column")
    updateSelectInput(inputId = "column", choices = names(dataset()))
  })
  
  output$summary <- renderPrint({
    summary(dataset()[[input$column]])
  })
}
```

preserve states

```{.r}
ui <- fluidPage(
  textInput("label", "label"),
  selectInput("type", "type", c("slider", "numeric")),
  uiOutput("numeric")
)

server <- function(input, output, session) {
  output$numeric <- renderUI({
    value <- isolate(input$dynamic)
    if (input$type == "slider") {
      sliderInput("dynamic", input$label, value = value, min = 0, max = 10)
    } else {
      numericInput("dynamic", input$label, value = value, min = 0, max = 10)
    }
  })
}
```


## Control Reactivity 

## Data Management with R6 