---
title: 'Shiny deisng patterns'
date: '2022-07-30'
categories: [R]
description: | 
  Tricks and patterns when building large shiny apps. 
draft: yes 
---

## Using modules 

## Dynamic updating 


You can resolve this problem by “freezing” the input with `freezeReactiveValue()`. This ensures that any reactive value or outputs that use the input won’t be updated until the next full round of invalidation.

```r
server <- function(input, output, session) {
  dataset <- reactive(get(input$dataset, "package:datasets"))
  
  observeEvent(input$dataset, {
    freezeReactiveValue(input, "column")
    updateSelectInput(inputId = "column", choices = names(dataset()))
  })
  
  output$summary <- renderPrint({
    summary(dataset()[[input$column]])
  })
}
```

preserve states

```{.r}
ui <- fluidPage(
  textInput("label", "label"),
  selectInput("type", "type", c("slider", "numeric")),
  uiOutput("numeric")
)

server <- function(input, output, session) {
  output$numeric <- renderUI({
    value <- isolate(input$dynamic)
    if (input$type == "slider") {
      sliderInput("dynamic", input$label, value = value, min = 0, max = 10)
    } else {
      numericInput("dynamic", input$label, value = value, min = 0, max = 10)
    }
  })
}
```


## Control Reactivity 

## Data Management with R6 
